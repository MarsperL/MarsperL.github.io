<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kubernetes知识梳理-核心组件 | 云野阁</title><meta name="author" content="云野阁"><meta name="copyright" content="云野阁"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="pod在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：  apiVersion &lt;string&gt; 版本，由kubernetes内部定义，版本号必须可以用kubectl api-versions查询到 kind &lt;string&gt;类型，由kubernetes内部定义，版本号必须可以用kubectl api-resources查询到 metadata &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes知识梳理-核心组件">
<meta property="og:url" content="https://marsperl.github.io/yyg/dc35290c/index.html">
<meta property="og:site_name" content="云野阁">
<meta property="og:description" content="pod在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：  apiVersion &lt;string&gt; 版本，由kubernetes内部定义，版本号必须可以用kubectl api-versions查询到 kind &lt;string&gt;类型，由kubernetes内部定义，版本号必须可以用kubectl api-resources查询到 metadata &amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://random-img.pupper.cn/api">
<meta property="article:published_time" content="2025-05-17T11:08:26.000Z">
<meta property="article:modified_time" content="2025-05-17T11:44:16.000Z">
<meta property="article:author" content="云野阁">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="运维">
<meta property="article:tag" content="k8s">
<meta property="article:tag" content="知识梳理">
<meta property="article:tag" content="pod">
<meta property="article:tag" content="Service">
<meta property="article:tag" content="Ingress">
<meta property="article:tag" content="PV&#x2F;PVC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://random-img.pupper.cn/api"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes知识梳理-核心组件",
  "url": "https://marsperl.github.io/yyg/dc35290c/",
  "image": "https://random-img.pupper.cn/api",
  "datePublished": "2025-05-17T11:08:26.000Z",
  "dateModified": "2025-05-17T11:44:16.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "云野阁",
      "url": "https://marsperl.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/MarsperL/MarsperL.github.io@1.2/img/icon.png"><link rel="canonical" href="https://marsperl.github.io/yyg/dc35290c/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://s4.zstatic.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://s4.zstatic.net/ajax/libs/egjs-infinitegrid/4.12.0/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes知识梳理-核心组件',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/parts.css"><link rel="stylesheet" href="/css/link.css"><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script defer src="/js/lunar.js"></script><script defer src="/js/day.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/rss2.xml" title="云野阁" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img520.com/iNvl5J.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">97</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-blog"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span> 随机一篇</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-brands fa-get-pocket"></i><span> 蓝口袋</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/pintree/index.html"><i class="fa-fw fa fa-search-plus"></i><span> 导航</span></a></li><li><a class="site-page child" href="/sand/"><i class="fa-fw fa fa-cube"></i><span> 繁沙</span></a></li><li><a class="site-page child" href="/trip/index.html"><i class="fa-fw fa-solid fa-earth-asia"></i><span> 星游记</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw fa-solid fa-star"></i><span> 书•影•音</span></a></li><li><a class="site-page child" href="/focusclock/time.html"><i class="fa-fw fas fa-clock"></i><span> 专注时钟</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-comments"></i><span> 聊天室</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 心语亭</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/yygrss/index.html"><i class="fa-fw fa-solid fa-square-rss"></i><span> 文界</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://random-img.pupper.cn/api);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img520.com/iNvl5J.png" alt="Logo"><span class="site-name">云野阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Kubernetes知识梳理-核心组件</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-blog"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="javascript:randomPost();"><i class="fa-fw fa-solid fa-shuffle"></i><span> 随机一篇</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-brands fa-get-pocket"></i><span> 蓝口袋</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/pintree/index.html"><i class="fa-fw fa fa-search-plus"></i><span> 导航</span></a></li><li><a class="site-page child" href="/sand/"><i class="fa-fw fa fa-cube"></i><span> 繁沙</span></a></li><li><a class="site-page child" href="/trip/index.html"><i class="fa-fw fa-solid fa-earth-asia"></i><span> 星游记</span></a></li><li><a class="site-page child" href="/share/"><i class="fa-fw fa-solid fa-star"></i><span> 书•影•音</span></a></li><li><a class="site-page child" href="/focusclock/time.html"><i class="fa-fw fas fa-clock"></i><span> 专注时钟</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-comments"></i><span> 聊天室</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 心语亭</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/yygrss/index.html"><i class="fa-fw fa-solid fa-square-rss"></i><span> 文界</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Kubernetes知识梳理-核心组件</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-17T11:08:26.000Z" title="发表于 2025-05-17 19:08:26">2025-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-17T11:44:16.000Z" title="更新于 2025-05-17 19:44:16">2025-05-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/">容器化</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A2%B3%E7%90%86%E6%80%BB%E7%BB%93/">梳理总结</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%A2%B3%E7%90%86%E6%80%BB%E7%BB%93/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">知识梳理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%B9%E5%99%A8%E5%8C%96/k8s/">k8s</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">15.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h2><p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ol>
<li><code>apiVersion &lt;string&gt;</code> 版本，由kubernetes内部定义，版本号必须可以用kubectl api-versions查询到</li>
<li><code>kind &lt;string&gt;</code>类型，由kubernetes内部定义，版本号必须可以用kubectl api-resources查询到</li>
<li><code>metadata &lt;object&gt;</code>元数据，主要是资源标识和说明，常用的有name、namespace、labelss等</li>
<li><code>spec &lt;object&gt;</code>描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述</li>
<li><code>status &lt;object&gt;</code>状态信息，里面的内容不需要定义，由kubernetes自动生成</li>
</ol>
<h3 id="Pod生命周期"><a href="#Pod生命周期" class="headerlink" title="Pod生命周期"></a>Pod生命周期</h3><p>将Pod对象从创建到结束的时间范围称为Pod的生命周期。其生命周期的主要过程如下：</p>
<ol>
<li>pod创建</li>
<li>运行初始化容器</li>
<li>运行主容器容器<br>（1）启动钩子、终止钩子<br>（2）存活性探测、就绪性探测</li>
<li>pod终止</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/0.png" class="" title="image">
<p>在整个生命周期中，P0d会出现5种状态，分别如下：</p>
<ol>
<li>挂起(Pending)：apiserveri已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中(Running)：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功(Succeeded)：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败(Failed)：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知(Unknown)：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ol>
<h4 id="pod的创建过程"><a href="#pod的创建过程" class="headerlink" title="pod的创建过程"></a>pod的创建过程</h4><p>通过kubectl将pod配置传输给apiserver，apiserver转化pod信息并存入etcd，再进行”握手“反馈。scheduler监听apiserver中pod信息的变化，使用算法为pod分配主机并更新apiserver的信息，对应node节点主机通过监听更新后的信息，创建容器并更新信息至apiserver，apiserver将最终信息存入etcd，至此pod创建完成。</p>
<blockquote>
<ol>
<li>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</li>
<li>apiServer开始生成pod对象的信息，并将信息存入etcd,然后返回确认信息至客户端</li>
<li>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</li>
<li>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</li>
<li>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</li>
<li>apiServer将接收到的pod状态信息存入etcd中</li>
</ol>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/1.png" class="" title="image">
<h4 id="pod的终止过程"><a href="#pod的终止过程" class="headerlink" title="pod的终止过程"></a>pod的终止过程</h4><p>用户发送删除pod命令，apiserver接受并更新信息，pod状态变为terminating。kubelet监听收到后，启动pod关闭指令，端点控制器监听到pod关闭指令，删除对应service资源，pod停止运行，kubelet请求apiServer将pod资源的宽限期设置为0从而完成删除操作，apiserver将最终信息存入etcd，至此pod删除完成。</p>
<blockquote>
<ol>
<li>用户向apiServer发送删除pod对象的命令</li>
<li>apiServer中的pod对象信息会随着时间的推移而更新，在宽限期内(默认30s),pod被视为dead</li>
<li>将pod标记为terminating状态</li>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li>
<li>pod对象中的容器进程收到停止信号</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li>
<li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li>
</ol>
</blockquote>
<h4 id="初试化容器"><a href="#初试化容器" class="headerlink" title="初试化容器"></a>初试化容器</h4><p>初始化容器是在Pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：<br>1、初始化容器必须运行完成直至结束，如果某个初始化容器运行失败，那么kubernetes需要重启它直至成功完成。<br>2、初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行。<br>初始化容器有很多的应用场景，下面列出的是最常见的几个：<br>1、提供主容器镜像中不具备的工具程序或自定义代码。<br>2、初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足。<br>接下来做一个案例，模拟下面这个需求：<br>假设要以主容器来运行Nginx，但是要求在运行Nginx之前要能够连接上MySQL和Redis所在的服务器。<br>为了简化测试，事先规定好MySQL和Redis所在的IP地址分别为192.168.18.103和192.168.18.104（注意，这两个IP都不能ping通，因为环境中没有这两个IP）。<br>创建pod-initcontainer.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-initcontainer</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">xudaxian</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span></span><br><span class="line">  <span class="attr">initContainers:</span> <span class="comment"># 初始化容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;until ping 192.168.18.103 -c 1;do echo waiting for mysql ...;sleep 2;done;&quot;</span>]</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">true</span> <span class="comment"># 使用特权模式运行容器</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-redis</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;until ping 192.168.18.104 -c 1;do echo waiting for redis ...;sleep 2;done;&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>执行命令后，test-mysql未创建成功，之后的容器也无法创建。修改ip为可访问ip后，重新执行命令，会按顺序创建成功</p>
<h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li><p>post start：容器创建之后执行，如果失败了会重启容器</p>
</li>
<li><p>pre stop：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</p>
</li>
</ul>
<p>钩子处理器支持使用下面的三种方式定义动作：</p>
<ul>
<li>exec命令：在容器内执行一次命令。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.......</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">     <span class="attr">postStart:</span> </span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">           <span class="attr">command:</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">             <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">.......</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tcpSocket：在当前容器尝试访问指定的socket。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.......</span></span><br><span class="line">   <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">         <span class="attr">tcpSocket:</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">.......</span></span><br></pre></td></tr></table></figure>
<ul>
<li>httpGet：在当前容器中向某url发起HTTP请求。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.......</span> </span><br><span class="line">   <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">         <span class="attr">httpGet:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">            <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">            <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span> <span class="comment">#主机地址  </span></span><br><span class="line">            <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">.......</span></span><br></pre></td></tr></table></figure>
<h4 id="容器探测"><a href="#容器探测" class="headerlink" title="容器探测"></a>容器探测</h4><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例“摘除”，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li><p>liveness probes：存活性探测，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器。</p>
</li>
<li><p>readiness probes：就绪性探测，用于检测应用实例是否可以接受请求，如果不能，k8s不会转发流量。</p>
</li>
</ul>
<blockquote>
<p>livenessProbe：存活性探测，决定是否重启容器。<br>readinessProbe：就绪性探测，决定是否将请求转发给容器。</p>
<p>k8s在1.16版本之后新增了startupProbe探针，用于判断容器内应用程序是否已经启动。如果配置了startupProbe探针，就会先禁止其他的探针，直到startupProbe探针成功为止，一旦成功将不再进行探测。</p>
</blockquote>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li>exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">     <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">          <span class="bullet">-</span>    <span class="string">cat</span></span><br><span class="line">          <span class="bullet">-</span>    <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
<ul>
<li>tcpSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">   <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
<ul>
<li>httpGet：调用容器内web应用的URL，如果返回的状态码在200和399之前，则认为程序正常，否则不正常。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">   <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">         <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">         <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">         <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line">         <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
<h4 id="重启策略"><a href="#重启策略" class="headerlink" title="重启策略"></a>重启策略</h4><p>在容器探测中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由Pod的重启策略决定的，Pod的重启策略有3种，分别如下：</p>
<ul>
<li>Always：容器失效时，自动重启该容器，默认值。</li>
<li>OnFailure：容器终止运行且退出码不为0时重启。</li>
<li>Never：不论状态如何，都不重启该容器。</li>
</ul>
<p>重启策略适用于Pod对象中的所有容器，首次需要重启的容器，将在其需要的时候立即进行重启，随后再次重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大的延迟时长。</p>
<h3 id="Pod的调度"><a href="#Pod的调度" class="headerlink" title="Pod的调度"></a>Pod的调度</h3><p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式。</p>
<ul>
<li>自动调度：运行在哪个Node节点上完全由Scheduler经过一系列的算法计算得出。</li>
<li>定向调度：NodeName、NodeSelector。</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity。</li>
<li>污点（容忍）调度：Taints、Toleration。</li>
</ul>
<h4 id="定向调度"><a href="#定向调度" class="headerlink" title="定向调度"></a>定向调度</h4><p>定向调度，指的是利用在Pod上声明的<code>nodeName</code>或<code>nodeSelector</code>，以此将Pod调度到期望的Node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过Pod运行失败而已。</p>
<h5 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h5><p>nodeName用于强制约束将Pod调度到指定的name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。<br>创建一个pod-nodename.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">xudaxian</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">k8s-node1</span> <span class="comment"># 指定调度到k8s-node1节点上</span></span><br></pre></td></tr></table></figure>
<h5 id="nodeSelector"><a href="#nodeSelector" class="headerlink" title="nodeSelector"></a>nodeSelector</h5><p>nodeSelector用于将Pod调度到添加了指定标签的Node节点上，它是通过kubernetes的label-selector机制实现的，换言之，在Pod创建之前，会由Scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将Pod调度到目标节点，该匹配规则是强制约束。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeselector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">nodeenv:</span> <span class="string">pro</span> <span class="comment"># 指定调度到具有nodeenv=pro的Node节点上</span></span><br></pre></td></tr></table></figure>
<h4 id="亲和性调度"><a href="#亲和性调度" class="headerlink" title="亲和性调度"></a>亲和性调度</h4><p>虽然定向调度的两种方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用的Node列表也不行，这就限制了它的使用场景。<br>基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在nodeSelector的基础之上进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使得调度更加灵活。Affinity主要分为三类：</p>
<ul>
<li>nodeAffinity（node亲和性）：以Node为目标，解决Pod可以调度到那些Node的问题。</li>
<li>podAffinity（pod亲和性）：以Pod为目标，解决Pod可以和那些已存在的Pod部署在同一个拓扑域中的问题。</li>
<li>podAntiAffinity（pod反亲和性）：以Pod为目标，解决Pod不能和那些已经存在的Pod部署在同一拓扑域中的问题。</li>
</ul>
<p>关于亲和性和反亲和性的使用场景的说明：</p>
<ul>
<li>亲和性：如果两个应用频繁交互，那么就有必要利用亲和性让两个应用尽可能的靠近，这样可以较少因网络通信而带来的性能损耗。</li>
<li>反亲和性：当应用采用多副本部署的时候，那么就有必要利用反亲和性让各个应用实例打散分布在各个Node上，这样可以提高服务的高可用性。</li>
</ul>
<h5 id="nodeAffinity（node亲和性）"><a href="#nodeAffinity（node亲和性）" class="headerlink" title="nodeAffinity（node亲和性）"></a>nodeAffinity（node亲和性）</h5><p>查看nodeAffinity的可选配置项：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pod.spec.affinity.nodeAffinity</span></span><br><span class="line">  <span class="string">requiredDuringSchedulingIgnoredDuringExecution</span>  <span class="string">Node节点必须满足指定的所有规则才可以，相当于硬限制</span></span><br><span class="line">    <span class="string">nodeSelectorTerms</span>  <span class="string">节点选择列表</span></span><br><span class="line">      <span class="string">matchFields</span>   <span class="string">按节点字段列出的节点选择器要求列表</span>  </span><br><span class="line">      <span class="string">matchExpressions</span>   <span class="string">按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line">        <span class="string">key</span>    <span class="string">键</span></span><br><span class="line">        <span class="string">values</span> <span class="string">值</span></span><br><span class="line">        <span class="string">operator</span> <span class="string">关系符</span> <span class="string">支持Exists,</span> <span class="string">DoesNotExist,</span> <span class="string">In,</span> <span class="string">NotIn,</span> <span class="string">Gt,</span> <span class="string">Lt</span></span><br><span class="line">  <span class="string">preferredDuringSchedulingIgnoredDuringExecution</span> <span class="string">优先调度到满足指定的规则的Node，相当于软限制</span> <span class="string">(倾向)</span>     </span><br><span class="line">    <span class="string">preference</span>   <span class="string">一个节点选择器项，与相应的权重相关联</span></span><br><span class="line">      <span class="string">matchFields</span> <span class="string">按节点字段列出的节点选择器要求列表</span></span><br><span class="line">      <span class="string">matchExpressions</span>   <span class="string">按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line">        <span class="string">key</span> <span class="string">键</span></span><br><span class="line">        <span class="string">values</span> <span class="string">值</span></span><br><span class="line">        <span class="string">operator</span> <span class="string">关系符</span> <span class="string">支持In,</span> <span class="string">NotIn,</span> <span class="string">Exists,</span> <span class="string">DoesNotExist,</span> <span class="string">Gt,</span> <span class="string">Lt</span>  </span><br><span class="line">    <span class="string">weight</span> <span class="string">倾向权重，在范围1-100。</span></span><br></pre></td></tr></table></figure>
<p>关系符的使用说明:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配存在标签的key为nodeenv的节点</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">Exists</span>   </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">In</span>    </span><br><span class="line">      <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span></span><br><span class="line">      <span class="attr">operator:</span> <span class="string">Gt</span>   </span><br><span class="line">      <span class="attr">values:</span> <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>
<p>演示requiredDuringSchedulingIgnoredDuringExecution：<br>○创建pod-nodeaffinity-required.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment"># node亲和性配置</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># Node节点必须满足指定的所有规则才可以，相当于硬规则，类似于定向调度</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span> <span class="comment"># 节点选择列表</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span> <span class="comment"># 匹配存在标签的key为nodeenv的节点，并且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>nodeAffinity的注意事项：</p>
<ul>
<li>如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都满足，Pod才能运行在指定的Node上。</li>
<li>如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可。</li>
<li>如果一个nodeSelectorTerms中有多个matchExpressions，则一个节点必须满足所有的才能匹配成功。</li>
<li>如果一个Pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的nodeAffinity的要求，则系统将忽略此变化。</li>
</ul>
</blockquote>
<h5 id="podAffinity（pod亲和性）"><a href="#podAffinity（pod亲和性）" class="headerlink" title="podAffinity（pod亲和性）"></a>podAffinity（pod亲和性）</h5><p>podAffinity主要实现以运行的Pod为参照，实现让新创建的Pod和参照的Pod在一个区域的功能。<br>PodAffinity的可选配置项：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">pod.spec.affinity.podAffinity</span></span><br><span class="line">  <span class="string">requiredDuringSchedulingIgnoredDuringExecution</span>  <span class="string">硬限制</span></span><br><span class="line">    <span class="string">namespaces</span> <span class="string">指定参照pod的namespace</span></span><br><span class="line">    <span class="string">topologyKey</span> <span class="string">指定调度作用域</span></span><br><span class="line">    <span class="string">labelSelector</span> <span class="string">标签选择器</span></span><br><span class="line">      <span class="string">matchExpressions</span>  <span class="string">按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line">        <span class="string">key</span>    <span class="string">键</span></span><br><span class="line">        <span class="string">values</span> <span class="string">值</span></span><br><span class="line">        <span class="string">operator</span> <span class="string">关系符</span> <span class="string">支持In,</span> <span class="string">NotIn,</span> <span class="string">Exists,</span> <span class="string">DoesNotExist.</span></span><br><span class="line">      <span class="string">matchLabels</span>    <span class="string">指多个matchExpressions映射的内容</span>  </span><br><span class="line">  <span class="string">preferredDuringSchedulingIgnoredDuringExecution</span> <span class="string">软限制</span>    </span><br><span class="line">    <span class="string">podAffinityTerm</span>  <span class="string">选项</span></span><br><span class="line">      <span class="string">namespaces</span></span><br><span class="line">      <span class="string">topologyKey</span></span><br><span class="line">      <span class="string">labelSelector</span></span><br><span class="line">         <span class="string">matchExpressions</span> </span><br><span class="line">            <span class="string">key</span>    <span class="string">键</span>  </span><br><span class="line">            <span class="string">values</span> <span class="string">值</span>  </span><br><span class="line">            <span class="string">operator</span></span><br><span class="line">         <span class="string">matchLabels</span> </span><br><span class="line">    <span class="string">weight</span> <span class="string">倾向权重，在范围1-1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>topologyKey用于指定调度的作用域，例如:</p>
<ul>
<li>如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围。</li>
<li>如果指定为beta.kubernetes.io/os，则以Node节点的操作系统类型来区分。</li>
</ul>
</blockquote>
<p>演示requiredDuringSchedulingIgnoredDuringExecution。<br>创建pod-podaffinity-requred.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-requred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment"># Pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span> <span class="comment"># 该Pod必须和拥有标签podenv=xxx或者podenv=yyy的Pod在同一个Node上，显然没有这样的Pod</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;yyy&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>
<h5 id="podAntiAffinity（pod反亲和性）"><a href="#podAntiAffinity（pod反亲和性）" class="headerlink" title="podAntiAffinity（pod反亲和性）"></a>podAntiAffinity（pod反亲和性）</h5><p>podAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod和参照的Pod不在一个区域的功能。<br>其配置方式和podAffinity一样。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podantiaffinity-requred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 容器配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">          <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">  <span class="attr">affinity:</span> <span class="comment"># 亲和性配置</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment"># Pod反亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">&quot;pro&quot;</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>
<h4 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h4><h5 id="污点（Taints）"><a href="#污点（Taints）" class="headerlink" title="污点（Taints）"></a>污点（Taints）</h5><p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加污点属性，来决定是否运行Pod调度过来。<br>Node被设置了污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。<br>污点的格式为：key=value:effect，key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可以调度。</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但是不会影响当前Node上已经存在的Pod。</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已经存在的Pod驱逐。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/2.webp" class="" title="污点的三种格式.png">
<h5 id="容忍（Toleration）"><a href="#容忍（Toleration）" class="headerlink" title="容忍（Toleration）"></a>容忍（Toleration）</h5><p>上面介绍了污点的作用，我们可以在Node上添加污点用来拒绝Pod调度上来，但是如果就是想让一个Pod调度到一个有污点的Node上去，这时候应该怎么做？这就需要使用到容忍。</p>
<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝Pod调度上去，Pod通过容忍忽略拒绝。</p>
</blockquote>
<p>容忍的详细配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">explain</span> <span class="string">pod.spec.tolerations</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">FIELDS:</span></span><br><span class="line">  <span class="string">key</span>       <span class="comment"># 对应着要容忍的污点的键，空意味着匹配所有的键</span></span><br><span class="line">  <span class="string">value</span>     <span class="comment"># 对应着要容忍的污点的值</span></span><br><span class="line">  <span class="string">operator</span>  <span class="comment"># key-value的运算符，支持Equal和Exists（默认）</span></span><br><span class="line">  <span class="string">effect</span>    <span class="comment"># 对应污点的effect，空意味着匹配所有影响</span></span><br><span class="line">  <span class="string">tolerationSeconds</span>   <span class="comment"># 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当operator为Equal的时候，如果Node节点有多个Taint，那么Pod每个Taint都需要容忍才能部署上去。<br>当operator为Exists的时候，有如下的三种写法：</p>
<ul>
<li>容忍指定的污点，污点带有指定的effect：</li>
<li>容忍指定的污点，不考虑具体的effect：</li>
<li>容忍一切污点（慎用）：</li>
</ul>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span> <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">NoExecute</span> <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span> <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 操作符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tolerations:</span> <span class="comment"># 容忍</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">operator:</span> <span class="string">Exists</span> <span class="comment"># 操作符</span></span><br></pre></td></tr></table></figure>
<h3 id="Pod控制器"><a href="#Pod控制器" class="headerlink" title="Pod控制器"></a>Pod控制器</h3><p>在kubernetes中，按照Pod的创建方式可以将其分为两类：</p>
<ul>
<li>自主式Pod：kubernetes直接创建出来的Pod，这种Pod删除后就没有了，也不会重建。</li>
<li>控制器创建Pod：通过Pod控制器创建的Pod，这种Pod删除之后还会自动重建。</li>
</ul>
<p>Pod控制器：Pod控制器是管理Pod的中间层，使用了Pod控制器之后，我们只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它就会创建出满足条件的Pod并确保每一个Pod处于用户期望的状态，如果Pod在运行中出现故障，控制器会基于指定的策略重启或重建Pod。<br>在kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p>
<ul>
<li>ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代。</li>
<li>ReplicaSet：保证指定数量的Pod运行，并支持Pod数量变更，镜像版本变更。</li>
<li>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、版本回退。</li>
<li>Horizontal Pod Autoscaler：可以根据集群负载自动调整Pod的数量，实现削峰填谷。</li>
<li>DaemonSet：在集群中的指定Node上都运行一个副本，一般用于守护进程类的任务。</li>
<li>Job：它创建出来的Pod只要完成任务就立即退出，用于执行一次性任务。</li>
<li>CronJob：它创建的Pod会周期性的执行，用于执行周期性的任务。</li>
<li>StatefulSet：管理有状态的应用。</li>
</ul>
<h4 id="ReplicaSet（RS）"><a href="#ReplicaSet（RS）" class="headerlink" title="ReplicaSet（RS）"></a>ReplicaSet（RS）</h4><p>ReplicaSet的主要作用是保证一定数量的Pod能够正常运行，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对Pod数量的扩缩容。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/3.png" class="" title="image-20250327184456480">
<p>ReplicaSet的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号 </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型 </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据 </span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签 </span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">rs</span> </span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述 </span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量 </span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些po</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则 </span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则 </span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125; </span><br><span class="line"><span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本 </span></span><br><span class="line">  <span class="attr">metadata:</span> </span><br><span class="line">    <span class="attr">labels:</span> </span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">  <span class="attr">spec:</span> </span><br><span class="line">    <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>在这里，需要新了解的配置项就是spec下面几个选项：</p>
<ul>
<li>replicas：指定副本数量，其实就是当然rs创建出来的Pod的数量，默认为1.</li>
<li>selector：选择器，它的作用是建立Pod控制器和Pod之间的关联关系，采用了Label Selector机制（在Pod模块上定义Label，在控制器上定义选择器，就可以表明当前控制器能管理哪些Pod了）。</li>
<li>template：模板，就是当前控制器创建Pod所使用的模板，里面其实就是前面学过的Pod的定义。</li>
</ul>
<h4 id="Deployment（Deploy）"><a href="#Deployment（Deploy）" class="headerlink" title="Deployment（Deploy）"></a>Deployment（Deploy）</h4><p>为了更好的解决服务编排的问题，kubernetes在v1.2版本开始，引入了Deployment控制器。值得一提的是，Deployment控制器并不直接管理Pod，而是通过管理ReplicaSet来间接管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment的功能比ReplicaSet强大。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/4.png" class="" title="image-20250327184720728">
<p>Deployment的主要功能如下：</p>
<ul>
<li>支持ReplicaSet的所有功能。</li>
<li>支持发布的停止、继续。</li>
<li>支持版本滚动更新和版本回退。</li>
</ul>
<p>Deployment的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号 </span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型 </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据 </span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签 </span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">deploy</span> </span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述 </span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量 </span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本，默认为10 </span></span><br><span class="line">  <span class="attr">paused:</span> <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false </span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 部署超时时间（s），默认是600 </span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略 </span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略 </span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新 </span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数 maxUnavailable: 30% # 最大不可用状态的    Pod 的最大值，可以为百分比，也可以为整数 </span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod </span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则 </span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则 </span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125; </span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本 </span></span><br><span class="line">    <span class="attr">metadata:</span> </span><br><span class="line">      <span class="attr">labels:</span> </span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span> </span><br><span class="line">    <span class="attr">spec:</span> </span><br><span class="line">      <span class="attr">containers:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> </span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span> </span><br><span class="line">        <span class="attr">ports:</span> </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p>Deployment支持两种镜像更新的策略：重建更新和滚动更新（默认），可以通过strategy选项进行配置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">strategy:</span> <span class="string">指定新的Pod替代旧的Pod的策略，支持两个属性</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">指定策略类型，支持两种策略</span></span><br><span class="line">    <span class="string">Recreate：在创建出新的Pod之前会先杀掉所有已经存在的Pod</span></span><br><span class="line">    <span class="string">RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本的Pod</span></span><br><span class="line">  <span class="string">rollingUpdate：当type为RollingUpdate的时候生效，用于为rollingUpdate设置参数，支持两个属性：</span></span><br><span class="line">    <span class="string">maxUnavailable：用来指定在升级过程中不可用的Pod的最大数量，默认为25%。</span></span><br><span class="line">    <span class="string">maxSurge：</span> <span class="string">用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span></span><br></pre></td></tr></table></figure>
<p>Deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 版本升级相关功能</span></span><br><span class="line"><span class="string">kubetl</span> <span class="string">rollout</span> <span class="string">参数</span> <span class="string">deploy</span> <span class="string">xx</span>  <span class="comment"># 支持下面的选择</span></span><br><span class="line"><span class="comment"># status 显示当前升级的状态</span></span><br><span class="line"><span class="comment"># history 显示升级历史记录</span></span><br><span class="line"><span class="comment"># pause 暂停版本升级过程</span></span><br><span class="line"><span class="comment"># resume 继续已经暂停的版本升级过程</span></span><br><span class="line"><span class="comment"># restart 重启版本升级过程</span></span><br><span class="line"><span class="comment"># undo 回滚到上一级版本 （可以使用--to-revision回滚到指定的版本）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>deployment之所以能够实现版本的回退，就是通过记录下历史的ReplicaSet来实现的，一旦想回滚到那个版本，只需要将当前版本的Pod数量降为0，然后将回退版本的Pod提升为目标数量即可。</p>
</blockquote>
<h4 id="金丝雀发布"><a href="#金丝雀发布" class="headerlink" title="金丝雀发布"></a>金丝雀发布</h4><p>Deployment支持更新过程中的控制，如暂停更新操作（pause）或继续更新操作（resume）。<br>例如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求到新版本的Pod应用，继续观察能够稳定的按照期望的方式运行，如果没有问题之后再继续完成余下的Pod资源的滚动更新，否则立即回滚操作。</p>
<h4 id="Horizontal-Pod-Autoscaler（HPA）"><a href="#Horizontal-Pod-Autoscaler（HPA）" class="headerlink" title="Horizontal Pod Autoscaler（HPA）"></a>Horizontal Pod Autoscaler（HPA）</h4><p>我们已经可以通过手动执行kubectl scale命令实现Pod的扩缩容，但是这显然不符合kubernetes的定位目标–自动化和智能化。kubernetes期望可以通过监测Pod的使用情况，实现Pod数量的自动调整，于是就产生了HPA这种控制器。<br>HPA可以获取每个Pod的利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA和之前的Deployment一样，也属于一种kubernetes资源对象，它通过追踪分析目标Pod的负载变化情况，来确定是否需要针对性的调整目标Pod的副本数。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/5.png" class="" title="image-20250327185417750">
<blockquote>
<p>若集群中没有收集资源使用情况的程序，可选择安装metrics-server</p>
</blockquote>
<p>测试示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-hpa</span> <span class="comment"># deployment的名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名类型</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span> <span class="comment"># 最小Pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment"># 最大Pod数量</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">3</span> <span class="comment"># CPU使用率指标</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>  <span class="comment"># 指定要控制的Nginx的信息</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<h4 id="DaemonSet（DS）"><a href="#DaemonSet（DS）" class="headerlink" title="DaemonSet（DS）"></a>DaemonSet（DS）</h4><p>DaemonSet类型的控制器可以保证集群中的每一台（或指定）节点上都运行一个副本，一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/6.png" class="" title="image-20250327185800807">
<p>DaemonSet控制器的特点：</p>
<ul>
<li>每向集群中添加一个节点的时候，指定的Pod副本也将添加到该节点上。</li>
<li>当节点从集群中移除的时候，Pod也会被垃圾回收。</li>
</ul>
<p>DaemonSet的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment">#命名空间</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">updateStrategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 最大不可用状态的Pod的最大值，可用为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理那些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">     <span class="attr">metadata:</span></span><br><span class="line">       <span class="attr">labels:</span></span><br><span class="line">         <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">       <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">           <span class="attr">ports:</span></span><br><span class="line">             <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h4 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h4><p>Job主要用于负责批量处理短暂的一次性任务。<br>Job的特点：</p>
<ul>
<li>当Job创建的Pod执行成功结束时，Job将记录成功结束的Pod数量。</li>
<li>当成功结束的Pod达到指定的数量时，Job将完成执行。</li>
</ul>
<blockquote>
<p>Job可以保证指定数量的Pod执行完成。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/7.png" class="" title="image-20250327185958115">
<p>Job的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="comment"># 名称</span></span><br><span class="line">  <span class="attr">namespace:</span>  <span class="comment">#命名空间</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">job</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定Job需要成功运行Pod的总次数，默认为1</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定Job在任一时刻应该并发运行Pod的数量，默认为1</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定Job可以运行的时间期限，超过时间还没结束，系统将会尝试进行终止</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定Job失败后进行重试的次数，默认为6</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择Pod，默认为false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理那些Pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">        <span class="attr">values:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建Pod模板</span></span><br><span class="line">     <span class="attr">metadata:</span></span><br><span class="line">       <span class="attr">labels:</span></span><br><span class="line">         <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">     <span class="attr">spec:</span></span><br><span class="line">       <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或OnFailure</span></span><br><span class="line">       <span class="attr">containers:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">           <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">           <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1;do echo $i;sleep 20;done&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于模板中的重启策略的说明：</p>
<ul>
<li>如果设置为OnFailure，则Job会在Pod出现故障的时候重启容器，而不是创建Pod，failed次数不变。</li>
<li>如果设置为Never，则Job会在Pod出现故障的时候创建新的Pod，并且故障Pod不会消失，也不会重启，failed次数+1。</li>
<li>如果指定为Always的话，就意味着一直重启，意味着Pod任务会重复执行，这和Job的定义冲突，所以不能设置为Always。</li>
</ul>
</blockquote>
<h4 id="CronJob（CJ）"><a href="#CronJob（CJ）" class="headerlink" title="CronJob（CJ）"></a>CronJob（CJ）</h4><p>CronJob控制器以 Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p>
<p>CronJob的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span></span><br><span class="line">  <span class="attr">failedJobHistoryLimit:</span> <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  <span class="attr">successfulJobHistoryLimit:</span> <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="comment"># 启动作业错误的超时时长</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">6</span></span><br><span class="line">      <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">matchExpressions:</span> <span class="string">规则</span></span><br><span class="line">          <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> </span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;</span>]</span><br><span class="line"><span class="string">需要重点解释的几个选项：</span></span><br><span class="line"><span class="attr">schedule:</span> <span class="string">cron表达式，用于指定任务的执行时间</span></span><br><span class="line">    <span class="string">*/1</span>    <span class="string">*</span>      <span class="string">*</span>    <span class="string">*</span>     <span class="string">*</span></span><br><span class="line">    <span class="string">&lt;分钟&gt;</span> <span class="string">&lt;小时&gt;</span> <span class="string">&lt;日&gt;</span> <span class="string">&lt;月份&gt;</span> <span class="string">&lt;星期&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">分钟</span> <span class="string">值从</span> <span class="number">0</span> <span class="string">到</span> <span class="number">59</span><span class="string">.</span></span><br><span class="line">    <span class="string">小时</span> <span class="string">值从</span> <span class="number">0</span> <span class="string">到</span> <span class="number">23</span><span class="string">.</span></span><br><span class="line">    <span class="string">日</span> <span class="string">值从</span> <span class="number">1</span> <span class="string">到</span> <span class="number">31</span><span class="string">.</span></span><br><span class="line">    <span class="string">月</span> <span class="string">值从</span> <span class="number">1</span> <span class="string">到</span> <span class="number">12</span><span class="string">.</span></span><br><span class="line">    <span class="string">星期</span> <span class="string">值从</span> <span class="number">0</span> <span class="string">到</span> <span class="number">6</span><span class="string">,</span> <span class="number">0</span> <span class="string">代表星期日</span></span><br><span class="line">    <span class="string">多个时间可以用逗号隔开；</span> <span class="string">范围可以用连字符给出；*可以作为通配符；</span> <span class="string">/表示每...</span></span><br><span class="line"><span class="attr">concurrencyPolicy:</span></span><br><span class="line">    <span class="attr">Allow:</span>   <span class="string">允许Jobs并发运行(默认)</span></span><br><span class="line">    <span class="attr">Forbid:</span>  <span class="string">禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</span></span><br><span class="line">    <span class="attr">Replace:</span> <span class="string">替换，取消当前正在运行的作业并用新作业替换它</span></span><br></pre></td></tr></table></figure>
<h4 id="StatefulSet（有状态）"><a href="#StatefulSet（有状态）" class="headerlink" title="StatefulSet（有状态）"></a>StatefulSet（有状态）</h4><p>无状态应用：</p>
<ul>
<li>认为Pod都是一样的。</li>
<li>没有顺序要求。</li>
<li>不用考虑在哪个Node节点上运行。</li>
<li>随意进行伸缩和扩展。</li>
</ul>
<p>有状态应用：</p>
<ul>
<li>有顺序的要求。</li>
<li>认为每个Pod都是不一样的。</li>
<li>需要考虑在哪个Node节点上运行。</li>
<li>需要按照顺序进行伸缩和扩展。</li>
<li>让每个Pod都是独立的，保持Pod启动顺序和唯一性。</li>
</ul>
<p>StatefulSet是Kubernetes提供的管理有状态应用的负载管理控制器。<br>StatefulSet部署需要HeadLinessService（无头服务）。</p>
<blockquote>
<p>为什么需要HeadLinessService（无头服务）？</p>
<ul>
<li>在用Deployment时，每一个Pod名称是没有顺序的，是随机字符串，因此是Pod名称是无序的，但是在StatefulSet中要求必须是有序 ，每一个Pod不能被随意取代，Pod重建后pod名称还是一样的。</li>
<li>而Pod IP是变化的，所以是以Pod名称来识别。Pod名称是Pod唯一性的标识符，必须持久稳定有效。这时候要用到无头服务，它可以给每个Pod一个唯一的名称 。</li>
</ul>
<p>StatefulSet常用来部署RabbitMQ集群、Zookeeper集群、MySQL集群、Eureka集群等。</p>
</blockquote>
<p>演示示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># Service的端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># Pod的端口</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-statefulset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>在kubernetes中，Pod是应用程序的载体，我们可以通过Pod的IP来访问应用程序，但是Pod的IP地址不是固定的，这就意味着不方便直接采用Pod的IP对服务进行访问。<br>为了解决这个问题，kubernetes提供了Service资源，Service会对提供同一个服务的多个Pod进行聚合，并且提供一个统一的入口地址，通过访问Service的入口地址就能访问到后面的Pod服务。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/8.png" class="" title="image-20250328172653361">
<p>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行了一个kube-proxy的服务进程。当创建Service的时候会通过API Server向etcd写入创建的Service的信息，而kube-proxy会基于监听的机制发现这种Service的变化，然后它会将最新的Service信息转换为对应的访问规则。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/9.png" class="" title="image-20250328172807052">
<p>kube-proxy目前支持三种工作模式：</p>
<ul>
<li><p>userspace模式：</p>
<ul>
<li><p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法（负载均衡算法）选择一个提供服务的Pod并和其建立连接，以便将请求转发到Pod上。</p>
</li>
<li><p>该模式下，kube-proxy充当了一个四层负载均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理的时候会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率非常低下。</p>
</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/10.png" class="" title="image-20250328172925938">
<ul>
<li><p>iptables模式：</p>
<ul>
<li><p>iptables模式下，kube-proxy为Service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod的IP上。</p>
</li>
<li><p>该模式下kube-proxy不承担四层负载均衡器的角色，只负责创建iptables规则。该模式的优点在于较userspace模式效率更高，但是不能提供灵活的LB策略，当后端Pod不可用的时候无法进行重试。</p>
</li>
</ul>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/11.png" class="" title="image-20250328173051549">
<p>ipvs模式：</p>
<ul>
<li>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高，除此之外，ipvs支持更多的LB（负载均衡）算法。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/12.png" class="" title="image-20250328173219942">
<h3 id="Service类型"><a href="#Service类型" class="headerlink" title="Service类型"></a>Service类型</h3><p>Service的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># 版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span> <span class="comment"># 类型</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前Service代理那些Pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># Service的类型，指定Service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="comment"># 虚拟服务的IP地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项，默认值为None</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># Service端口</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 协议</span></span><br><span class="line">      <span class="attr">targetPort :</span> <span class="comment"># Pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span>  <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>spec.type的说明：</p>
<ul>
<li>ClusterIP：默认值，它是kubernetes系统自动分配的虚拟IP，只能在集群内部访问。</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务。</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境的支持。</li>
<li>ExternalName：把集群外部的服务引入集群内部，直接使用。</li>
</ul>
</blockquote>
<h4 id="ClusterIP类型的Service"><a href="#ClusterIP类型的Service" class="headerlink" title="ClusterIP类型的Service"></a>ClusterIP类型的Service</h4><p>Endpoint（实际中使用的不多）</p>
<ul>
<li>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有Pod的访问地址，它是根据service配置文件中的selector描述产生的。</li>
<li>一个service由一组Pod组成，这些Pod通过Endpoints暴露出来，Endpoints是实现实际服务的端点集合。换言之，service和Pod之间的联系是通过Endpoints实现的。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/13.png" class="" title="image-20250328173454822">
<p> 负载分发策略</p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li>如果不定义，默认使用kube-proxy的策略，比如随机、轮询等。</li>
<li>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上，这对于传统基于Session的认证项目来说很友好，此模式可以在spec中添加sessionAffinity: ClusterIP选项。</li>
</ul>
<h4 id="HeadLiness类型的Service"><a href="#HeadLiness类型的Service" class="headerlink" title="HeadLiness类型的Service"></a>HeadLiness类型的Service</h4><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLinesss Service，这类Service不会分配Cluster IP，如果想要访问Service，只能通过Service的域名进行查询。</p>
<h4 id="NodePort类型的Service"><a href="#NodePort类型的Service" class="headerlink" title="NodePort类型的Service"></a>NodePort类型的Service</h4><p>在之前的案例中，创建的Service的IP地址只能在集群内部才可以访问，如果希望Service暴露给集群外部使用，那么就需要使用到另外一种类型的Service，称为NodePort类型的Service。NodePort的工作原理就是将Service的端口映射到Node的一个端口上，然后就可以通过NodeIP:NodePort来访问Service了。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/14.png" class="" title="image-20250328173809010">
<h4 id="LoadBalancer类型的Service"><a href="#LoadBalancer类型的Service" class="headerlink" title="LoadBalancer类型的Service"></a>LoadBalancer类型的Service</h4><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/15.png" class="" title="image-20250328173923606">
<h4 id="ExternalName类型的Service"><a href="#ExternalName类型的Service" class="headerlink" title="ExternalName类型的Service"></a>ExternalName类型的Service</h4><p>ExternalName类型的Service用于引入集群外部的服务，它通过externalName属性指定一个服务的地址，然后在集群内部访问此Service就可以访问到外部的服务了。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/16.png" class="" title="image-20250328174018302">
<h2 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h2><p>我们已经知道，Service对集群之外暴露服务的主要方式有两种：NodePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显。</li>
<li>LoadBalancer的缺点是每个Service都需要一个LB，浪费，麻烦，并且需要kubernetes之外的设备的支持。</li>
</ul>
<p>基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求，工作机制大致如下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/17.png" class="" title="image-20250328174120763">
<p>实际上，Ingress相当于一个七层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解为Ingress里面建立了诸多映射规则，Ingress Controller通过监听这些配置规则并转化为Nginx的反向代理配置，然后对外提供服务。</p>
<ul>
<li>Ingress：kubernetes中的一个对象，作用是定义请求如何转发到Service的规则。</li>
<li>Ingress Controller：具体实现反向代理及负载均衡的程序，对Ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现的方式有很多，比如Nginx，Contour，Haproxy等。</li>
</ul>
<p>Ingress（以Nginx）的工作原理如下：</p>
<ul>
<li>用户编写Ingress规则，说明那个域名对应kubernetes集群中的那个Service。</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx的反向代理配置。</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新。</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求规则。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/18.png" class="" title="image-20250328174300573">
<blockquote>
<p>Ingress支持Http代理和Https代理</p>
</blockquote>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h3 id="基本存储"><a href="#基本存储" class="headerlink" title="基本存储"></a>基本存储</h3><h4 id="EmptyDir"><a href="#EmptyDir" class="headerlink" title="EmptyDir"></a>EmptyDir</h4><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p>
<p>EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p>
<ul>
<li>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</li>
<li>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</li>
</ul>
<p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p>
<p>在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向Volume中写日志，busybox中通过命令将日志内容读到控制台。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/19.png" class="" title="image-20250328174613499">
<h4 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h4><p>上节课提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/20.png" class="" title="image-20250328174658800">
<h4 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h4><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p>
<p>NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/21.png" class="" title="image-20250328174744542">
<h3 id="高级存储"><a href="#高级存储" class="headerlink" title="高级存储"></a>高级存储</h3><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p>
<ul>
<li>PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</li>
<li>PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/22.png" class="" title="image-20250329114433511">
<p>使用了PV和PVC之后，工作可以得到进一步的细分：</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV： kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h4 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h4><p>PV是存储资源的抽象，下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型，与底层真正存储对应</span></span><br><span class="line">  <span class="attr">capacity:</span>  <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span>  <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>
<p>PV 的关键配置参数说明：</p>
<ul>
<li><p><strong>存储类型</strong></p>
<p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p>
</li>
<li><p><strong>存储能力（capacity）</strong></p>
</li>
</ul>
<p>目前只支持存储空间的设置( storage=1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p>
<ul>
<li><p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p>
</li>
<li><p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p>
<p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p>
<ul>
<li>Retain （保留） 保留数据，需要管理员手工清理数据</li>
<li>Recycle（回收） 清除 PV 中的数据，效果相当于执行 rm -rf /thevolume/*</li>
<li>Delete （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的回收策略不同</code></p>
</li>
<li><p><strong>存储类别</strong></p>
<p>PV可以通过storageClassName参数指定一个存储类别</p>
<ul>
<li>具有特定类别的PV只能与请求了该类别的PVC进行绑定</li>
<li>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</li>
</ul>
</li>
<li><p><strong>状态（status）</strong></p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>Available（可用）： 表示可用状态，还未被任何 PVC 绑定</li>
<li>Bound（已绑定）： 表示 PV 已经被 PVC 绑定</li>
<li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）： 表示该 PV 的自动回收失败</li>
</ul>
</li>
</ul>
<h4 id="PVC"><a href="#PVC" class="headerlink" title="PVC"></a>PVC</h4><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>
<p>PVC 的关键配置参数说明：</p>
<ul>
<li><strong>访问模式（accessModes）</strong></li>
</ul>
<p>用于描述用户应用对存储资源的访问权限</p>
<ul>
<li><p><strong>选择条件（selector）</strong></p>
<p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p>
</li>
<li><p><strong>存储类别（storageClassName）</strong></p>
<p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p>
</li>
<li><p><strong>资源请求（Resources ）</strong></p>
<p>描述对存储资源的请求</p>
</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p>
<ul>
<li><p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p>
</li>
<li><p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定</p>
<p>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p>
<ul>
<li>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</li>
<li>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</li>
</ul>
<p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p>
</li>
<li><p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p>
<p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p>
</li>
<li><p><strong>资源释放</strong>：用户删除pvc来释放pv</p>
<p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p>
</li>
<li><p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p>
<p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/23.png" class="" title="img">
<h4 id="配置存储"><a href="#配置存储" class="headerlink" title="配置存储"></a>配置存储</h4><h5 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h5><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p>
<p>创建configmap.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    username:admin</span></span><br><span class="line"><span class="string">    password:123456</span></span><br></pre></td></tr></table></figure>
<p>接下来，使用此配置文件创建configmap</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建configmap</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl create -f configmap.yaml</span></span><br><span class="line"><span class="string">configmap/configmap</span> <span class="string">created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看configmap详情</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl describe cm configmap -n dev</span></span><br><span class="line"><span class="attr">Name:</span>         <span class="string">configmap</span></span><br><span class="line"><span class="attr">Namespace:</span>    <span class="string">dev</span></span><br><span class="line"><span class="attr">Labels:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Annotations:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">Data</span></span><br><span class="line"><span class="string">====</span></span><br><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="string">....</span></span><br><span class="line"><span class="string">username:admin</span></span><br><span class="line"><span class="string">password:123456</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Events:</span>  <span class="string">&lt;none&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来创建一个pod-configmap.yaml，将上面创建的configmap挂载进去</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将configmap挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/configmap/config</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 引用configmap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl create -f pod-configmap.yaml</span></span><br><span class="line"><span class="string">pod/pod-configmap</span> <span class="string">created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl get pod pod-configmap -n dev</span></span><br><span class="line"><span class="string">NAME</span>            <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">pod-configmap</span>   <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">6s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl exec -it pod-configmap -n dev /bin/sh</span></span><br><span class="line"><span class="comment"># cd /configmap/config/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line"><span class="string">info</span></span><br><span class="line"><span class="comment"># more info</span></span><br><span class="line"><span class="string">username:admin</span></span><br><span class="line"><span class="string">password:123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到映射已经成功，每个configmap都映射成了一个目录</span></span><br><span class="line"><span class="comment"># key表示文件     value表示文件中的内容</span></span><br><span class="line"><span class="comment"># 此时如果更新configmap的内容, 容器中的值也会动态更新</span></span><br></pre></td></tr></table></figure>
<h5 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h5><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>
<p>首先使用base64对数据进行编码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># echo -n &#x27;admin&#x27; | base64 #准备username</span></span><br><span class="line"><span class="string">YWRtaW4=</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># echo -n &#x27;123456&#x27; | base64 #准备password</span></span><br><span class="line"><span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>
<p>接下来编写secret.yaml，并创建Secret</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span></span><br><span class="line"><span class="comment"># 创建secret</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl create -f secret.yaml</span></span><br><span class="line"><span class="string">secret/secret</span> <span class="string">created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看secret详情</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl describe secret secret -n dev</span></span><br><span class="line"><span class="attr">Name:</span>         <span class="string">secret</span></span><br><span class="line"><span class="attr">Namespace:</span>    <span class="string">dev</span></span><br><span class="line"><span class="attr">Labels:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Annotations:</span>  <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Type:</span>  <span class="string">Opaque</span></span><br><span class="line"><span class="string">Data</span></span><br><span class="line"><span class="string">====</span></span><br><span class="line"><span class="attr">password:</span>  <span class="number">6</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">username:</span>  <span class="number">5</span> <span class="string">bytes</span></span><br></pre></td></tr></table></figure>
<p>创建pod-secret.yaml，将上面创建的secret挂载进去：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将secret挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/secret/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">secret</span></span><br><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl create -f pod-secret.yaml</span></span><br><span class="line"><span class="string">pod/pod-secret</span> <span class="string">created</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl get pod pod-secret -n dev</span></span><br><span class="line"><span class="string">NAME</span>            <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">pod-secret</span>      <span class="number">1</span><span class="string">/1</span>     <span class="string">Running</span>   <span class="number">0</span>          <span class="string">2m28s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，查看secret信息，发现已经自动解码了</span></span><br><span class="line">[<span class="string">root@k8s-master01</span> <span class="string">~</span>]<span class="comment"># kubectl exec -it pod-secret /bin/sh -n dev</span></span><br><span class="line"><span class="string">/</span> <span class="comment"># ls /secret/config/</span></span><br><span class="line"><span class="string">password</span>  <span class="string">username</span></span><br><span class="line"><span class="string">/</span> <span class="comment"># more /secret/config/username</span></span><br><span class="line"><span class="string">admin</span></span><br><span class="line"><span class="string">/</span> <span class="comment"># more /secret/config/password</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>至此，已经实现了利用secret实现了信息的编码。</p>
<h2 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a>安全认证</h2><p>Kubernetes作为一个分布式集群的管理工具，保证集群的安全性是其一个重要的任务。所谓的安全性其实就是保证对Kubernetes的各种<strong>客户端</strong>进行<strong>认证和鉴权</strong>操作。</p>
<p><strong>客户端</strong></p>
<p>在Kubernetes集群中，客户端通常有两类：</p>
<ul>
<li><strong>User Account</strong>：一般是独立于kubernetes之外的其他服务管理的用户账号。</li>
<li><strong>Service Account</strong>：kubernetes管理的账号，用于为Pod中的服务进程在访问Kubernetes时提供身份标识。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/24.png" class="" title="img">
<p><strong>认证、授权与准入控制</strong></p>
<p>ApiServer是访问及管理资源对象的唯一入口。任何一个请求访问ApiServer，都要经过下面三个流程：</p>
<ul>
<li>Authentication（认证）：身份鉴别，只有正确的账号才能够通过认证</li>
<li>Authorization（授权）： 判断用户是否有权限对访问的资源执行特定的动作</li>
<li>Admission Control（准入控制）：用于补充授权机制以实现更加精细的访问控制功能。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/25.png" class="" title="img">
<h3 id="认证管理"><a href="#认证管理" class="headerlink" title="认证管理"></a>认证管理</h3><p>Kubernetes集群安全的最关键点在于如何识别并认证客户端身份，它提供了3种客户端身份认证方式：</p>
<ul>
<li>HTTP Base认证：通过用户名+密码的方式认证</li>
</ul>
<p>这种认证方式是把“用户名:密码”用BASE64算法进行编码后的字符串放在HTTP请求中的Header Authorization域里发送给服务端。服务端收到后进行解码，获取用户名及密码，然后进行用户身份认证的过程。</p>
<ul>
<li>HTTP Token认证：通过一个Token来识别合法用户</li>
</ul>
<p>这种认证方式是用一个很长的难以被模仿的字符串—Token来表明客户身份的一种方式。每个Token对应一个用户名，当客户端发起API调用请求时，需要在HTTP Header里放入Token，API Server接到Token后会跟服务器中保存的token进行比对，然后进行用户身份认证的过程。</p>
<ul>
<li>HTTPS证书认证：基于CA根证书签名的双向数字证书认证方式</li>
</ul>
<p>这种认证方式是安全性最高的一种方式，但是同时也是操作起来最麻烦的一种方式。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/26.png" class="" title="img">
<p><strong>HTTPS认证大体分为3个过程：</strong></p>
<ol>
<li>证书申请和下发</li>
</ol>
<p>​    HTTPS通信双方的服务器向CA机构申请证书，CA机构下发根证书、服务端证书及私钥给申请者</p>
<ol>
<li>客户端和服务端的双向认证</li>
</ol>
<p>（1） 客户端向服务器端发起请求，服务端下发自己的证书给客户端， 客户端接收到证书后，通过私钥解密证书，在证书中获得服务端的公钥， 客户端利用服务器端的公钥认证证书中的信息，如果一致，则认可这个服务器<br>（2）客户端发送自己的证书给服务器端，服务端接收到证书后，通过私钥解密证书，在证书中获得客户端的公钥，并用该公钥认证证书信息，确认客户端是否合法</p>
<ol>
<li>服务器端和客户端进行通信</li>
</ol>
<p>服务器端和客户端协商好加密方案后，客户端会产生一个随机的秘钥并加密，然后发送到服务器端。<br>服务器端接收这个秘钥后，双方接下来通信的所有内容都通过该随机秘钥加密</p>
<blockquote>
<p>注意: Kubernetes允许同时配置多种认证方式，只要其中任意一个方式认证通过即可</p>
</blockquote>
<h3 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h3><p>授权发生在认证成功之后，通过认证就可以知道请求用户是谁， 然后Kubernetes会根据事先定义的授权策略来决定用户是否有权限访问，这个过程就称为授权。</p>
<p>每个发送到ApiServer的请求都带上了用户和资源的信息：比如发送请求的用户、请求的路径、请求的动作等，授权就是根据这些信息和授权策略进行比较，如果符合策略，则认为授权通过，否则会返回错误。</p>
<p>API Server目前支持以下几种授权策略：</p>
<ul>
<li>AlwaysDeny：表示拒绝所有请求，一般用于测试</li>
<li>AlwaysAllow：允许接收所有请求，相当于集群不需要授权流程（Kubernetes默认的策略）</li>
<li>ABAC：基于属性的访问控制，表示使用用户配置的授权规则对用户请求进行匹配和控制</li>
<li>Webhook：通过调用外部REST服务对用户进行授权</li>
<li>Node：是一种专用模式，用于对kubelet发出的请求进行访问控制</li>
<li>RBAC：基于角色的访问控制（kubeadm安装方式下的默认选项）</li>
</ul>
<p>RBAC(Role-Based Access Control) 基于角色的访问控制，主要是在描述一件事情：<strong>给哪些对象授予了哪些权限</strong></p>
<p>其中涉及到了下面几个概念：</p>
<ul>
<li>对象：User、Groups、ServiceAccount</li>
<li>角色：代表着一组定义在资源上的可操作动作(权限)的集合</li>
<li>绑定：将定义好的角色跟用户绑定在一起</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/yyg/dc35290c/27.png" class="" title="img">
<p>RBAC引入了4个顶级资源对象：</p>
<ul>
<li>Role、ClusterRole：角色，用于指定一组权限</li>
<li>RoleBinding、ClusterRoleBinding：角色绑定，用于将角色（权限）赋予给对象</li>
</ul>
<p><strong>Role、ClusterRole</strong></p>
<p>一个角色就是一组权限的集合，这里的权限都是许可形式的（白名单）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Role只能对命名空间内的资源进行授权，需要指定nameapce</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]  <span class="comment"># 支持的API组列表,&quot;&quot; 空字符串，表示核心API群</span></span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>] <span class="comment"># 支持的资源对象列表</span></span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>] <span class="comment"># 允许的对资源对象的操作方法列表</span></span><br><span class="line"><span class="comment"># ClusterRole可以对集群范围内资源、跨namespaces的范围资源、非资源类型进行授权</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;watch&quot;</span>, <span class="string">&quot;list&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>需要详细说明的是，rules中的参数：</p>
<ul>
<li>apiGroups: 支持的API组列表</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span><span class="string">,&quot;apps&quot;,</span> <span class="string">&quot;autoscaling&quot;</span><span class="string">,</span> <span class="string">&quot;batch&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>resources：支持的资源对象列表</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;services&quot;</span><span class="string">,</span> <span class="string">&quot;endpoints&quot;</span><span class="string">,</span> <span class="string">&quot;pods&quot;</span><span class="string">,&quot;secrets&quot;,&quot;configmaps&quot;,&quot;crontabs&quot;,&quot;deployments&quot;,&quot;jobs&quot;,</span></span><br><span class="line"><span class="string">&quot;nodes&quot;</span><span class="string">,&quot;rolebindings&quot;,&quot;clusterroles&quot;,&quot;daemonsets&quot;,&quot;replicasets&quot;,&quot;statefulsets&quot;,</span></span><br><span class="line"><span class="string">&quot;horizontalpodautoscalers&quot;</span><span class="string">,&quot;replicationcontrollers&quot;,&quot;cronjobs&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>verbs：对资源对象的操作方法列表</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;get&quot;</span><span class="string">,</span> <span class="string">&quot;list&quot;</span><span class="string">,</span> <span class="string">&quot;watch&quot;</span><span class="string">,</span> <span class="string">&quot;create&quot;</span><span class="string">,</span> <span class="string">&quot;update&quot;</span><span class="string">,</span> <span class="string">&quot;patch&quot;</span><span class="string">,</span> <span class="string">&quot;delete&quot;</span><span class="string">,</span> <span class="string">&quot;exec&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>RoleBinding、ClusterRoleBinding</strong></p>
<p>角色绑定用来把一个角色绑定到一个目标对象上，绑定目标可以是User、Group或者ServiceAccount。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RoleBinding可以将同一namespace中的subject绑定到某个Role下，则此subject即具有该Role定义的权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="comment"># ClusterRoleBinding在整个集群级别和所有namespaces将特定的subject与ClusterRole绑定，授予权限</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">authorization-clusterrole-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<p><strong>RoleBinding引用ClusterRole进行授权</strong></p>
<p>RoleBinding可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。</p>
<p>一种很常用的做法就是，集群管理员为集群范围预定义好一组角色（ClusterRole），然后在多个命名空间中重复使用这些ClusterRole。这样可以大幅提高授权管理工作效率，也使得各个命名空间下的基础性授权规则与使用体验保持一致。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 虽然authorization-clusterrole是一个集群角色，但是因为使用了RoleBinding</span></span><br><span class="line"><span class="comment"># 所以heima只能读取dev命名空间中的资源</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-role-binding-ns</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heima</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">authorization-clusterrole</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>
<h3 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h3><p>通过了前面的认证和授权之后，还需要经过准入控制处理通过之后，apiserver才会处理这个请求。</p>
<p>准入控制是一个可配置的控制器列表，可以通过在Api-Server上通过命令行设置选择执行哪些准入控制器：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">--admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,</span></span><br><span class="line">                      <span class="string">DefaultStorageClass,ResourceQuota,DefaultTolerationSeconds</span></span><br></pre></td></tr></table></figure>
<p>只有当所有的准入控制器都检查通过之后，apiserver才执行该请求，否则返回拒绝。</p>
<p>当前可配置的Admission Control准入控制如下：</p>
<ul>
<li>AlwaysAdmit：允许所有请求</li>
<li>AlwaysDeny：禁止所有请求，一般用于测试</li>
<li>AlwaysPullImages：在启动容器之前总去下载镜像</li>
<li>DenyExecOnPrivileged：它会拦截所有想在Privileged Container上执行命令的请求</li>
<li>ImagePolicyWebhook：这个插件将允许后端的一个Webhook程序来完成admission controller的功能。</li>
<li>Service Account：实现ServiceAccount实现了自动化</li>
<li>SecurityContextDeny：这个插件将使用SecurityContext的Pod中的定义全部失效</li>
<li>ResourceQuota：用于资源配额管理目的，观察所有请求，确保在namespace上的配额不会超标</li>
<li>LimitRanger：用于资源限制管理，作用于namespace上，确保对Pod进行资源限制</li>
<li>InitialResources：为未设置资源请求与限制的Pod，根据其镜像的历史资源的使用情况进行设置</li>
<li>NamespaceLifecycle：如果尝试在一个不存在的namespace中创建资源对象，则该创建请求将被拒绝。当删除一个namespace时，系统将会删除该namespace中所有对象。</li>
<li>DefaultStorageClass：为了实现共享存储的动态供应，为未指定StorageClass或PV的PVC尝试匹配默认的StorageClass，尽可能减少用户在申请PVC时所需了解的后端存储细节</li>
<li>DefaultTolerationSeconds：这个插件为那些没有设置forgiveness tolerations并具有notready:NoExecute和unreachable:NoExecute两种taints的Pod设置默认的“容忍”时间，为5min</li>
<li>PodSecurityPolicy：这个插件用于在创建或修改Pod时决定是否根据Pod的security context和可用的PodSecurityPolicy对Pod的安全策略进行控制</li>
</ul>
<blockquote>
<p>本篇知识来源于B站视频BV1Qv41167ck</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://marsperl.github.io/">云野阁</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://marsperl.github.io/yyg/dc35290c/">https://marsperl.github.io/yyg/dc35290c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://MarsperL.github.io" target="_blank">云野阁</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/%E8%BF%90%E7%BB%B4/">运维</a><a class="post-meta__tags" href="/tags/k8s/">k8s</a><a class="post-meta__tags" href="/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/">知识梳理</a><a class="post-meta__tags" href="/tags/pod/">pod</a><a class="post-meta__tags" href="/tags/Service/">Service</a><a class="post-meta__tags" href="/tags/Ingress/">Ingress</a><a class="post-meta__tags" href="/tags/PV-PVC/">PV/PVC</a></div><div class="post-share"><div class="social-share" data-image="https://random-img.pupper.cn/api" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/yyg/46758d12/" title="Android手机安装docker"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.vvhan.com/api/wallpaper/views" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Android手机安装docker</div></div><div class="info-2"><div class="info-item-1">Android手机使用ALPINE-TERM 安装dockerAlpine Term 是一款基于 Termux 的安卓应用，集成了 QEMU 虚拟机 和 Alpine Linux，支持在安卓手机上免 Root 运行完整的 Linux...</div><div class="content">Android手机使用ALPINE-TERM 安装dockerAlpine Term 是一款基于 Termux 的安卓应用，集成了 QEMU 虚拟机 和 Alpine Linux，支持在安卓手机上免 Root 运行完整的 Linux 环境， ...</div></div></div></a><a class="pagination-related" href="/yyg/f0979e05/" title="Jenkins知识梳理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.jiangyuhui.top/aliyun/randomCover" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Jenkins知识梳理</div></div><div class="info-2"><div class="info-item-1"> 🔜什么是Jenkins？🔚                               Jenkins是一款基于Java开发的开源 CI&amp;CD...</div><div class="content"> 🔜什么是Jenkins？🔚 
              
              Jenkins是一款基于Java开发的开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。Jenkins提供多种安装方式 ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/yyg/f5a7a3df/" title="Kubernetes知识梳理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.vvhan.com/api/wallpaper/views" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-24</div><div class="info-item-2">Kubernetes知识梳理</div></div><div class="info">
  e720fb8297af95c5ceb1b2b23a14166113f676c1d922569bd3835ccc599188b96b1ab4bada4b58df261f12fcb4b43d2c5111d66b577e34f467257 ...</div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a><a class="pagination-related" href="/yyg/5c56de6f/" title="docker知识梳理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgapi.cn/api.php?fl=fengjing&gs=images" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-24</div><div class="info-item-2">docker知识梳理</div></div><div class="info">
  e720fb8297af95c5ceb1b2b23a14166113f676c1d922569bd3835ccc599188b9a2b61cee022cd32f80a50dd00a8e93de64b1f8a3bafd3d390d9ad ...</div><div class="info-2"><div class="info-item-1">  ...</div></div></div></a><a class="pagination-related" href="/yyg/3b57c0c6/" title="docker容器日志配置管理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tu.ltyuanfang.cn/api/fengjing.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-07</div><div class="info-item-2">docker容器日志配置管理</div></div><div class="info">运行的项目容器突然就停了，查看容器日志发现磁盘空间不足，导致容器没法运行了。

Error response from daemon: Cannot restart container docker-p: mkdir /home/docke ...</div><div class="info-2"><div class="info-item-1">运行的项目容器突然就停了，查看容器日志发现磁盘空间不足，导致容器没法运行了。  Error response from daemon: Cannot restart container docker-p: mkdir...</div></div></div></a><a class="pagination-related" href="/yyg/9ec93abd/" title="Linux实现模拟IPMI"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgapi.cn/api.php?fl=fengjing&gs=images" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-10</div><div class="info-item-2">Linux实现模拟IPMI</div></div><div class="info">环境准备：（1）使用脚本安装docker、docker-compose
1bash &lt;(curl -sSL https://linuxmirrors.cn/docker.sh)
（2）配置镜像加速
123456789101112131 ...</div><div class="info-2"><div class="info-item-1">环境准备：（1）使用脚本安装docker、docker-compose 1bash &lt;(curl -sSL...</div></div></div></a><a class="pagination-related" href="/yyg/fd02fe22/" title="Slim缩小容器镜像大小"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.jiangyuhui.top/aliyun/randomCover" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-05</div><div class="info-item-2">Slim缩小容器镜像大小</div></div><div class="info">前言 🔜Slim🔚 
              
              GitHub - slimtoolkit/slim： Slim（toolkit）：不要更改容器镜像中的任何内容，并将其缩小多达 30 倍（对于编译语言甚至更 ...</div><div class="info-2"><div class="info-item-1">前言 🔜Slim🔚                               GitHub - slimtoolkit/slim： Slim（toolkit）：不要更改容器镜像中的任何内容，并将其缩小多达 30...</div></div></div></a><a class="pagination-related" href="/yyg/d3a49a0e/" title="Watchtower自动更新docker容器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://picapi.pai.al/api/scenery.php" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-10</div><div class="info-item-2">Watchtower自动更新docker容器</div></div><div class="info">基础环境系统：openEuler 22.03 (LTS-SP4) X86
软件：docker-26.1.3、 docker compose-2.27.0
关于WatchtowerWatchtower 是一个应用程序，监控正在运行的 Dock ...</div><div class="info-2"><div class="info-item-1">基础环境系统：openEuler 22.03 (LTS-SP4) X86 软件：docker-26.1.3、 docker compose-2.27.0 关于WatchtowerWatchtower 是一个应用程序，监控正在运行的...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Giscus</span><span id="switch-btn"></span><span class="second-comment">Gitalk</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img520.com/iNvl5J.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">云野阁</div><div class="author-info-description">闲云野鹤，八方逍遥</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">97</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/MarsperL" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:MjcxMTYxMzE4MkBxcS5jb20=" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/rss2.xml" target="_blank" title=""><i class="fas fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#pod"><span class="toc-number">1.</span> <span class="toc-text">pod</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.</span> <span class="toc-text">Pod生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pod%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">pod的创建过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">pod的终止过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E8%AF%95%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">初试化容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">钩子函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8E%A2%E6%B5%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">容器探测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc-number">1.1.6.</span> <span class="toc-text">重启策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">Pod的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E5%90%91%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.1.</span> <span class="toc-text">定向调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nodeName"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">nodeName</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#nodeSelector"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">nodeSelector</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%B2%E5%92%8C%E6%80%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">亲和性调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#nodeAffinity%EF%BC%88node%E4%BA%B2%E5%92%8C%E6%80%A7%EF%BC%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">nodeAffinity（node亲和性）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#podAffinity%EF%BC%88pod%E4%BA%B2%E5%92%8C%E6%80%A7%EF%BC%89"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">podAffinity（pod亲和性）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#podAntiAffinity%EF%BC%88pod%E5%8F%8D%E4%BA%B2%E5%92%8C%E6%80%A7%EF%BC%89"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">podAntiAffinity（pod反亲和性）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E5%92%8C%E5%AE%B9%E5%BF%8D"><span class="toc-number">1.2.3.</span> <span class="toc-text">污点和容忍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%EF%BC%88Taints%EF%BC%89"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">污点（Taints）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%B9%E5%BF%8D%EF%BC%88Toleration%EF%BC%89"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">容忍（Toleration）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.3.</span> <span class="toc-text">Pod控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReplicaSet%EF%BC%88RS%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">ReplicaSet（RS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deployment%EF%BC%88Deploy%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">Deployment（Deploy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83"><span class="toc-number">1.3.3.</span> <span class="toc-text">金丝雀发布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Horizontal-Pod-Autoscaler%EF%BC%88HPA%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">Horizontal Pod Autoscaler（HPA）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DaemonSet%EF%BC%88DS%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">DaemonSet（DS）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Job"><span class="toc-number">1.3.6.</span> <span class="toc-text">Job</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CronJob%EF%BC%88CJ%EF%BC%89"><span class="toc-number">1.3.7.</span> <span class="toc-text">CronJob（CJ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StatefulSet%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81%EF%BC%89"><span class="toc-number">1.3.8.</span> <span class="toc-text">StatefulSet（有状态）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service"><span class="toc-number">2.</span> <span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Service%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">Service类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ClusterIP%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">2.1.1.</span> <span class="toc-text">ClusterIP类型的Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HeadLiness%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">2.1.2.</span> <span class="toc-text">HeadLiness类型的Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NodePort%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">2.1.3.</span> <span class="toc-text">NodePort类型的Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LoadBalancer%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">2.1.4.</span> <span class="toc-text">LoadBalancer类型的Service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ExternalName%E7%B1%BB%E5%9E%8B%E7%9A%84Service"><span class="toc-number">2.1.5.</span> <span class="toc-text">ExternalName类型的Service</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ingress"><span class="toc-number">3.</span> <span class="toc-text">Ingress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">4.</span> <span class="toc-text">数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AD%98%E5%82%A8"><span class="toc-number">4.1.</span> <span class="toc-text">基本存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EmptyDir"><span class="toc-number">4.1.1.</span> <span class="toc-text">EmptyDir</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HostPath"><span class="toc-number">4.1.2.</span> <span class="toc-text">HostPath</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NFS"><span class="toc-number">4.1.3.</span> <span class="toc-text">NFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.</span> <span class="toc-text">高级存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PV"><span class="toc-number">4.2.1.</span> <span class="toc-text">PV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PVC"><span class="toc-number">4.2.2.</span> <span class="toc-text">PVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.2.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AD%98%E5%82%A8"><span class="toc-number">4.2.4.</span> <span class="toc-text">配置存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ConfigMap"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">ConfigMap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Secret"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">Secret</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81"><span class="toc-number">5.</span> <span class="toc-text">安全认证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E7%AE%A1%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">认证管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">授权管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%85%A5%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">准入控制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/yyg/46758d12/" title="Android手机安装docker"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.vvhan.com/api/wallpaper/views" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android手机安装docker"/></a><div class="content"><a class="title" href="/yyg/46758d12/" title="Android手机安装docker">Android手机安装docker</a><time datetime="2025-05-17T11:45:50.000Z" title="发表于 2025-05-17 19:45:50">2025-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/yyg/c86be486/" title="Android手机安装ubuntu"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/04/03/542674_9ad613de0540a41a.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Android手机安装ubuntu"/></a><div class="content"><a class="title" href="/yyg/c86be486/" title="Android手机安装ubuntu">Android手机安装ubuntu</a><time datetime="2025-05-17T11:45:50.000Z" title="发表于 2025-05-17 19:45:50">2025-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/yyg/dc35290c/" title="Kubernetes知识梳理-核心组件"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://random-img.pupper.cn/api" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kubernetes知识梳理-核心组件"/></a><div class="content"><a class="title" href="/yyg/dc35290c/" title="Kubernetes知识梳理-核心组件">Kubernetes知识梳理-核心组件</a><time datetime="2025-05-17T11:08:26.000Z" title="发表于 2025-05-17 19:08:26">2025-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/yyg/f0979e05/" title="Jenkins知识梳理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.jiangyuhui.top/aliyun/randomCover" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Jenkins知识梳理"/></a><div class="content"><a class="title" href="/yyg/f0979e05/" title="Jenkins知识梳理">Jenkins知识梳理</a><time datetime="2025-05-17T10:47:41.000Z" title="发表于 2025-05-17 18:47:41">2025-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/yyg/10ac2e4/" title="Ansible最新版安装"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgapi.cn/api.php?fl=fengjing&amp;gs=images" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ansible最新版安装"/></a><div class="content"><a class="title" href="/yyg/10ac2e4/" title="Ansible最新版安装">Ansible最新版安装</a><time datetime="2025-04-12T09:35:43.000Z" title="发表于 2025-04-12 17:35:43">2025-04-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By 云野阁</div><div class="footer_custom_text"><div id="runtime"></div> 世界上只有一种真正的英雄主义，那就是看清生活的真相之后，依然热爱生活</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js?v=5.3.5"></script><script src="/js/main.js?v=5.3.5"></script><script src="https://s4.zstatic.net/ajax/libs/fancyapps-ui/5.0.36/fancybox/fancybox.umd.min.js"></script><script src="https://s4.zstatic.net/ajax/libs/vanilla-lazyload/19.1.3/lazyload.iife.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.4.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"data-lang":"zh-CN","data-input-position":"bottom"}

  const getGiscusTheme = theme => theme === 'dark' ? 'noborder_dark' : 'noborder_light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'MarsperL/MarsperL.github.io',
      'data-repo-id': 'R_kgDOHV6bsQ',
      'data-category-id': 'DIC_kwDOHV6bsc4Cd54m',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"language":"zh-CN","perPage":10,"distractionFreeMode":false,"pagerDirection":"last","labels":["Gitalk"],"enableHotKey":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"}

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23lihCNRWnXie4OU7t',
      clientSecret: '29543cc1a69d0e6b735d7dab092aba69ca62a5b2',
      repo: 'yygrss',
      owner: 'MarsperL',
      admin: ['MarsperL'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'a05db45b7107d4749b6bee7dc6e53cf5'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Giscus' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Giscus' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/js/parts.js"></script><script src="/js/background.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.3.5"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/30035ff1/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.picgo.net/2024/04/03/542674_9ad613de0540a41a.jpeg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-11</span><a class="blog-slider__title" href="yyg/30035ff1/" alt="">一些免费的gpt网站</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/30035ff1/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/c60df0d6/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgapi.cn/api.php?fl=fengjing&amp;gs=images" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-24</span><a class="blog-slider__title" href="yyg/c60df0d6/" alt="">使用portainer管理容器</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/c60df0d6/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/4451cec/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img520.com/iNvl5J.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-31</span><a class="blog-slider__title" href="yyg/4451cec/" alt="">x86服务器构建ARM架构docker镜像</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/4451cec/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/71468332/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://random-img.pupper.cn/api" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-08</span><a class="blog-slider__title" href="yyg/71468332/" alt="">Docker Swarm集群部署</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/71468332/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/5ea27f40/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.vvhan.com/api/wallpaper/views" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-26</span><a class="blog-slider__title" href="yyg/5ea27f40/" alt="">在Github上使用OsmosFeed搭建在线RSS阅读器（无需服务器）</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/5ea27f40/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/ca46b09/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://random-img.pupper.cn/api" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-08-07</span><a class="blog-slider__title" href="yyg/ca46b09/" alt="">Hexo-Butterfly美化教程-[9]繁沙</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/ca46b09/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="yyg/60ed202a/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgapi.cn/api.php?fl=fengjing&amp;gs=images" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-08</span><a class="blog-slider__title" href="yyg/60ed202a/" alt="">实现Docker 容器跨主机通讯</a><div class="blog-slider__text">点击查看置顶文章啦~~~</div><a class="blog-slider__button" href="yyg/60ed202a/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>